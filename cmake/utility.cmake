####################################################################################
#                                                                                  #
#  Copyright (c) 2014 - 2018 Axel Menzel <info@rttr.org>                           #
#                                                                                  #
#  This file is part of RTTR (Run Time Type Reflection)                            #
#  License: MIT License                                                            #
#                                                                                  #
#  Permission is hereby granted, free of charge, to any person obtaining           #
#  a copy of this software and associated documentation files (the "Software"),    #
#  to deal in the Software without restriction, including without limitation       #
#  the rights to use, copy, modify, merge, publish, distribute, sublicense,        #
#  and/or sell copies of the Software, and to permit persons to whom the           #
#  Software is furnished to do so, subject to the following conditions:            #
#                                                                                  #
#  The above copyright notice and this permission notice shall be included in      #
#  all copies or substantial portions of the Software.                             #
#                                                                                  #
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR      #
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        #
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE     #
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          #
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   #
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   #
#  SOFTWARE.                                                                       #
#                                                                                  #
####################################################################################

####################################################################################
# Welcome to the CMake build system for RTTR.
# This file contains several helper function to make the life easier with cmake.
####################################################################################

####################################################################################
# create hierarchical source groups, useful for big VS-Projects
# FILE_LIST <= a list of files with absolute path
####################################################################################
function (createSrcGroups FILE_LIST )
  # we want to get the relative path from the
  # current source dir
  string(LENGTH ${CMAKE_CURRENT_SOURCE_DIR} curDirLen)
  set(TMP_FILE_LIST ${${FILE_LIST}})

  foreach ( SOURCE ${TMP_FILE_LIST} )
    string(LENGTH ${SOURCE} fullPathLen)
    math(EXPR RelPathLen ${fullPathLen}-${curDirLen})
    string(SUBSTRING ${SOURCE} ${curDirLen} ${RelPathLen} curStr)

    string ( REGEX REPLACE "[\\/]" "\\\\" normPath ${curStr} )
    string ( REGEX MATCH "\\\\(.*)\\\\" ouput ${normPath} )
    if(NOT CMAKE_MATCH_1 STREQUAL "")
      source_group ( ${CMAKE_MATCH_1} FILES ${SOURCE} )
    endif()
  endforeach()
endfunction()

####################################################################################
# Create a UnityFile. This is a file which inlcudes all other source files.
# This is usefull, when you want a fast rebuild.
# _UNITY_FILE <= The name of the UnityFile
# _SRC_FILES <= The list of source files
####################################################################################
function(generateUnityFile _UNITY_FILE _SRC_FILES)
  set(files ${${_SRC_FILES}})
  # Generate a unique filename for the unity build translation unit
  set(unit_build_file ${CMAKE_CURRENT_BINARY_DIR}/ub_${_UNITY_FILE}.cpp)
  set_source_files_properties(${files} PROPERTIES HEADER_FILE_ONLY true)
  # Open the ub file
  FILE(WRITE ${unit_build_file} "// Unity Build generated by CMake\n")
  # Add include statement for each translation unit
  foreach(sourceFile ${files} )
    #FILE( APPEND ${unit_build_file} "#include <${CMAKE_CURRENT_SOURCE_DIR}/${sourceFile}>\n")
    FILE( APPEND ${unit_build_file} "#include \"${sourceFile}\"\n")
  endforeach()
  # Complement list of translation units with the name of ub
  set(${_UNITY_FILE} ${unit_build_file} PARENT_SCOPE)
  source_group("Generated Files" FILES ${unit_build_file})
endfunction()

####################################################################################
# Returns the name of the Directory, where the file in the FILE_PATH is located.
####################################################################################
function(getNameOfDir FILE_PATH DIR_NAME)
  get_filename_component(HAS_FILE_IN_PATH ${${FILE_PATH}} EXT)
  if (HAS_FILE_IN_PATH)
    get_filename_component(PATH_WITHOUT_FILENAME ${${FILE_PATH}} PATH)
    get_filename_component(NAME_OF_DIR  ${PATH_WITHOUT_FILENAME} NAME)
    set(${DIR_NAME} ${NAME_OF_DIR} PARENT_SCOPE)
  else()
    get_filename_component(NAME_OF_DIR ${${FILE_PATH}} NAME)
    set(${DIR_NAME} ${NAME_OF_DIR} PARENT_SCOPE)
  endif()
endfunction()

####################################################################################
# This function checks if the current generator is used for a Viusal Studio build
# _INPUT This variable will be set to TRUE if its a Visual Studio build, otherwise to FALSE.
####################################################################################
function (is_vs_based_build _INPUT)
  if(${CMAKE_GENERATOR} MATCHES "Visual Studio")
    set(${_INPUT} TRUE PARENT_SCOPE)
  else()
    set(${_INPUT} FALSE PARENT_SCOPE)
  endif()
endfunction()

####################################################################################
# Copy a release dependency in the correct CMAKE_RUNTIME_OUTPUT_DIRECTORY
# _INPUT The full path of the dependency incl. FileName
# _OUTPUT The directory where the libraries should be installed.
# OPTIONAL: RELATIVE Path - as third argument an optional relative path can be specified
####################################################################################

function(copy_dependency_release _INPUT _OUTPUT)
  is_vs_based_build(VS_BUILD)

  # when this is a DEBUG build we dont copy the files
  if(NOT VS_BUILD)
    if(${CMAKE_BUILD_TYPE} STREQUAL Debug)
      return()
    endif()
  endif()
  # as third argument an optional relative path can be specified
  set(REL_PATH ${ARGV2})
  set(_PATH ${_INPUT})
  # make the path to normal path with / as dir separator
  string ( REGEX REPLACE "[\\/]" "/" FILE_PATH ${_PATH} )
  get_filename_component(FILE_NAME ${FILE_PATH} NAME)

  if (VS_BUILD)
    if (IS_DIRECTORY ${_INPUT})
      file(COPY ${_INPUT} DESTINATION ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/Release/${REL_PATH})
    else()
      configure_file(${FILE_PATH} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/Release/${REL_PATH}/${FILE_NAME} COPYONLY)
      configure_file(${FILE_PATH} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/RelWithDebInfo/${REL_PATH}/${FILE_NAME} COPYONLY)
      configure_file(${FILE_PATH} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/MinSizeRel/${REL_PATH}/${FILE_NAME} COPYONLY)
    endif()
  else()
    if (IS_DIRECTORY ${_INPUT})
      file(COPY ${_INPUT} DESTINATION ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${REL_PATH})
    else()
      configure_file(${FILE_PATH} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${REL_PATH}/${FILE_NAME} COPYONLY)
    endif()
  endif()

  if (IS_DIRECTORY ${_INPUT})
    install(DIRECTORY
            ${FILE_PATH}
            DESTINATION ${_OUTPUT}/${REL_PATH}
            CONFIGURATIONS Release)
  else()
    install(FILES
            ${FILE_PATH}
            DESTINATION ${_OUTPUT}/${REL_PATH}
            CONFIGURATIONS Release)
  endif()
endfunction()

####################################################################################
# Copy a debug dependency in the correct CMAKE_RUNTIME_OUTPUT_DIRECTORY
# _INPUT The full path of the dependency incl. FileName
# _OUTPUT The directory where the libraries should be installed.
# OPTIONAL: RELATIVE Path - as third argument an optional relative path can be specified
####################################################################################

function(copy_dependency_debug _INPUT _OUTPUT)
  is_vs_based_build(VS_BUILD)

  # when this is NOT a DEBUG build we dont copy the files
  if(NOT VS_BUILD)
    if(NOT ${CMAKE_BUILD_TYPE} STREQUAL Debug)
      return()
    endif()
  endif()
  # as third argument an optional relative path can be specified
  set(REL_PATH ${ARGV2})
  set(_PATH ${_INPUT})
  # make the path to normal path with / as dir separator
  string ( REGEX REPLACE "[\\/]" "////" FILE_PATH ${_PATH} )
  get_filename_component(FILE_NAME ${FILE_PATH} NAME)

  if (VS_BUILD)
    if (IS_DIRECTORY ${_INPUT})
      file(COPY ${_INPUT} DESTINATION ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/Debug/${REL_PATH})
     else()
      configure_file(${FILE_PATH} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/Debug/${REL_PATH}/${FILE_NAME} COPYONLY)
    endif()
  else()
    if (IS_DIRECTORY ${_INPUT})
      file(COPY ${_INPUT} DESTINATION ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${REL_PATH})
    else()
      configure_file(${FILE_PATH} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${REL_PATH}/${FILE_NAME} COPYONLY)
    endif()
  endif()

 if (IS_DIRECTORY ${_INPUT})
   install(DIRECTORY
           ${FILE_PATH}
           DESTINATION ${_OUTPUT}/${REL_PATH}
           CONFIGURATIONS Debug)
 else()
   install(FILES
           ${FILE_PATH}
           DESTINATION ${_OUTPUT}/${REL_PATH}
           CONFIGURATIONS Debug)
  endif()
endfunction()

####################################################################################
# Adds warnings compiler options to the target depending on the category
# target Target name
####################################################################################
function( set_compiler_warnings target)
  if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    set(WARNINGS "-Werror"
                 "-Wall")
  elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    set(WARNINGS "-Werror"
                 "-Wall")
  elseif(MSVC)
    set(WARNINGS "/WX"
                 "/W4")
  endif()

  target_compile_options(${target} PRIVATE ${WARNINGS}) 
endfunction()

####################################################################################
# Adds or replace a compiler option
# _OLD_OPTION The option which should be replaced
# _NEW_OPTION The new option which should be added
####################################################################################
function( replace_compiler_option _OLD_OPTION _NEW_OPTION)
  foreach(flag_var
          CMAKE_CXX_FLAGS CMAKE_CXX_FLAGS_DEBUG CMAKE_CXX_FLAGS_RELEASE
          CMAKE_CXX_FLAGS_MINSIZEREL CMAKE_CXX_FLAGS_RELWITHDEBINFO)
    if(${flag_var} MATCHES ${_OLD_OPTION})
      # the whitespace after_OLD_OPTION is necessary to really match only the flag and not some sub flag (/MD should match by /MDd)
      string(REGEX REPLACE "${_OLD_OPTION} " "${_NEW_OPTION} " ${flag_var} "${${flag_var}}")
    else()
      set(${flag_var} "${${flag_var}} ${_NEW_OPTION} ")
    endif()
   set(${flag_var} ${${flag_var}} PARENT_SCOPE)
  endforeach()
endfunction()

####################################################################################
# enables or disables the user of RTTI for all following source files.
# _ENABLE If true, will enable RTTI, otherwise will disable RTTI.
####################################################################################
macro(enable_rtti _ENABLE)
  set(enable_rtti_opt "")
  set(disable_rtti_opt "")
  if (MSVC)
    set(enable_rtti_opt "/GR")
    set(disable_rtti_opt "/GR-")
  elseif(CMAKE_COMPILER_IS_GNUCXX )
    set(enable_rtti_opt "-frtti")
    set(disable_rtti_opt "-fno-rtti")
  elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    set(enable_rtti_opt "-frtti")
    set(disable_rtti_opt "-fno-rtti")
  else()
    message(FATAL_ERROR "Don't know how to enable/disable RTTI for this compiler.")
  endif()

  if (${_ENABLE})
    message(STATUS "Enabled: use of RTTI")
    replace_compiler_option("${disable_rtti_opt}" "${enable_rtti_opt}")
  else()
    message(STATUS "Disabled: use of RTTI")
    replace_compiler_option("${enable_rtti_opt}" "${disable_rtti_opt}")
  endif()
endmacro()

####################################################################################
# This will install the PDB files also into the "bin" folder of the installation directory
# _TARGET_NAME The name of the target
####################################################################################

function(install_pdb_files _TARGET_NAME)
    if (MSVC)
        install(FILES $<TARGET_PDB_FILE:${_TARGET_NAME}> DESTINATION "bin" CONFIGURATIONS Debug RelWithDebInfo)
    endif()
endfunction()


####################################################################################
# Get environment variable, define it as ENV_$var and make sure backslashes are converted to forward slashes
# _COMPILER_NAME
####################################################################################
macro(getenv_path VAR)
   set(ENV_${VAR} $ENV{${VAR}})
   # replace won't work if var is blank
   if (ENV_${VAR})
     string( REGEX REPLACE "\\\\" "/" ENV_${VAR} ${ENV_${VAR}} )
   endif ()
endmacro()

function(get_latest_supported_cxx CXX_STANDARD)
    if (POLICY CMP0067)
        cmake_policy(SET CMP0067 NEW)
    endif()
    
    # we need to set CMAKE_CXX_STANDARD in order to use the flags for 'check_cxx_source_compiles'
    set(CMAKE_CXX_STANDARD 17)

    include(CheckCXXSourceCompiles)

    check_cxx_source_compiles("
                              #include <type_traits>
                              typedef void F();
                              typedef void G() noexcept;
                              
                              std::enable_if<
                                  !std::is_same<F, G>::value,
                                  int
                              >::type i = 42;
                              
                              int main() { return 0; }
                              "
                              HAS_NO_EXCEPT_TYPE_SIGNATURE_SUPPORT)

    check_cxx_source_compiles("
                              #include <type_traits>
                              struct foo { void func() const noexcept {} };
                              template<typename T>
                              void test_func(T)
                              {
                                  static_assert(std::is_member_function_pointer<T>::value, \"Failed\");
                              }
                              int main() { test_func(&foo::func); return 0; }
                              " 
                              HAS_STL_NO_EXCEPT_TYPE_SIGNATURE_SUPPORT)
                              
    check_cxx_source_compiles("
                              constexpr int abs(int x)
                              {
                                  if(x < 0) x = -x;
                                  return x;
                              }
                              
                              int main() { }
                              "
                              HAS_CXX_CONSTEXPR)
                              
    check_cxx_source_compiles( "
                               #include <type_traits>
                               template<typename T>
                               struct template_type_trait : std::false_type {};
                               
                               template<template < bool > class T, bool N>
                               struct template_type_trait<T<N>> : std::true_type {};
                               
                               template<template <std::size_t> class T, std::size_t N>
                               struct template_type_trait<T<N>> : std::true_type {};
                               
                               template<std::size_t T>
                               struct bar{};
                               
                               int main() { static bool foo = template_type_trait<bar<100>>::value;}
                               "
                               HAS_PARTIAL_SPECIALIZATION_FOR_ARRAYS)

    if (HAS_NO_EXCEPT_TYPE_SIGNATURE_SUPPORT AND HAS_STL_NO_EXCEPT_TYPE_SIGNATURE_SUPPORT AND
        HAS_PARTIAL_SPECIALIZATION_FOR_ARRAYS AND HAS_CXX_CONSTEXPR)
        set(MAX_CXX_STD 17)
    else()
        message(FATAL_ERROR "最低需要c++17")
    endif()
    
    set(${CXX_STANDARD} ${MAX_CXX_STD} PARENT_SCOPE)
endfunction()

# 创建文件生成函数
function(create_file_target target_name output_file content)
    # 创建生成脚本
    set(script_content "
cmake_minimum_required(VERSION 3.18)
file(WRITE \"${output_file}\" \"${content}\")
message(STATUS \"Generated: ${output_file}\")
")
    
    # 写入临时脚本
    set(script_file ${CMAKE_BINARY_DIR}/cmake/generate_${target_name}.cmake)
    file(WRITE ${script_file} "${script_content}")
    
    # 创建自定义目标
    add_custom_target(${target_name}
        COMMAND ${CMAKE_COMMAND} -P ${script_file}
        COMMENT "Generating ${output_file}"
        VERBATIM
    )
endfunction()

#收集目标头文件(在配置时)
function(collect_dependency_target_recursive_impl target result visited)
    list(APPEND ${visited} ${target})
    
    # 递归处理依赖
    get_target_property(link_libs ${target} INTERFACE_LINK_LIBRARIES)
    if(NOT link_libs)
        get_target_property(link_libs ${target} LINK_LIBRARIES)
    endif()
    
    foreach(lib ${link_libs})
        if(TARGET ${lib})
            if(NOT "${lib}" IN_LIST "${visited}")
                list(APPEND ${result} ${lib})
                collect_dependency_target_recursive_impl(${lib} ${result} "${visited}")
            endif()
        endif()
    endforeach()
    
    set(${result} "${${result}}" PARENT_SCOPE)
endfunction()

function(collect_dependency_target_recursive target result)
    set(visited "")
    collect_dependency_target_recursive_impl(${target} ${result} visited)
    list(REMOVE_DUPLICATES ${result})
    set(${result} "${${result}}" PARENT_SCOPE)
endfunction()

#收集目标头文件(在配置时)
function(collect_includes_recursive target result)

    collect_dependency_target_recursive(${target} OUT_LIBS)
    list(APPEND OUT_LIBS ${target})
    
    # 获取接口包含目录
    foreach(target_item ${OUT_LIBS})
        get_target_property(includes ${target_item} INCLUDE_DIRECTORIES)
        get_target_property(interface_includes ${target_item} INTERFACE_INCLUDE_DIRECTORIES)
        # 获取系统包含目录
        get_target_property(system_includes ${target_item} INTERFACE_SYSTEM_INCLUDE_DIRECTORIES)
        if(includes)
            list(APPEND ${result} ${includes})
        endif()
        if(interface_includes)
            list(APPEND ${result} ${interface_includes})
        endif()
        if(system_includes)
            list(APPEND ${result} ${system_includes})
        endif()
    endforeach()
    
    list(REMOVE_DUPLICATES ${result})
    set(${result} "${${result}}" PARENT_SCOPE)
endfunction()